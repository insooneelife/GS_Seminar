직렬화 과제

_3_Chat_answer의 채팅 프로그램에 직렬화를 이용한 기능을 추가한다.

기존의 채팅 프로그램에서는 char*을 이용하여 문자열을 보내는 형태로 통신을 수행한다.
전체적으로 문자열을 전송하는 부분을 flatbuffer를 이용하여 packet을 만들어서 전송하도록 변경하고,
채팅 기록을 만들어서, 새로운 사용자가 접속했을 때 이전 사용자들이 어떤 대화를 했었는지를 보여주는 기능을 추가해보자.

다음과 같은 packet들을 만든다.

1) Login Packet

LoginPacket.fbs 파일 작성

	namespace MyGame;

	table LoginPacket 
	{
		name:string;	// 접속자의 이름 => 프로그램 시작 전에 입력받도록 한다.
	}

	root_type LoginPacket;
	
위 파일을 flatc로 컴파일하면 코드가 생성된다.
그 코드를 이용하여 data를 직렬화하고, type 정보와 함께 GameMessage로 감싸서 보내도록 한다.

Login packet은 프로그램 시작 시 client에서 server로 보낸다.
Server에서는 이 packet을 받으면,
<name 문자열, ip address>를 쌍으로 하는 map<string, SocketAddress>과
<ip address, name 문자열>를 쌍으로 하는 map<SocketAddress, string>에 저장한다.

해당 client에게 Okay packet을 보낸다.

만약 name이 이미 있다면, 무시한다.



2) Okay Packet

	namespace MyGame;

	table OkayPacket 
	{
		chat_list:[Message];	// 현재까지 채팅한 기록
	}

	table Message 
	{
		name:string;		// 이름
		message:string;		// 전송한 message
	}
	
	root_type OkayPacket;


위 파일을 flatc로 컴파일하면 코드가 생성된다.
그 코드를 이용하여 data를 직렬화하고, type 정보와 함께 GameMessage로 감싸서 보내도록 한다.

Okay packet은 client가 접속하였을 때 server가 방금 접속한 client에게 보내주는 packet이다.
현재까지의 채팅 기록에 대한 data를 OkayPacket으로 만들고 전송한다.

Client에서 이 packet을 받으면, chat_list에 있는 모든 Message를 "name : message" 형태로 화면에 출력한다.


3) Message Packet

MessagePacket.fbs 파일 작성

	namespace MyGame;

	table MessagePacket 
	{
		name:string		// 메시지를 보낸 사용자 name
		message:string;	// 보낼 메시지
	}
	
	root_type MessagePacket;

위 파일을 flatc로 컴파일하면 코드가 생성된다.
그 코드를 이용하여 data를 직렬화하고, type 정보와 함께 GameMessage로 감싸서 보내도록 한다.
	
Message packet은 작성할 문자열과 누가 작성했는지를 담은 packet이다.
Client에서 사용자 입력을 받고 enter를 누르면 packet이 보내진다.

Server에서는 packet을 받으면 <name, message> 쌍으로 chat list에 저장한다.  ex) list<pair<string, string>> 
저장 후 모든 client에게 받은 message packet을 보낸다.

Client에서 message packet을 받으면, "name : message" 형태로 화면에 출력한다.




